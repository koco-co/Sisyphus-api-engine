# ==============================================================================
# JSONPath 高级功能演示
# ==============================================================================
# 本示例展示 Sisyphus API Engine 的 JSONPath 高级功能
# 包括：过滤表达式、通配符、数组索引、变量嵌套引用、微秒时间戳
# ==============================================================================

name: "JSONPath 高级功能演示"
description: "演示 JSONPath 过滤表达式、变量嵌套引用和微秒时间戳"

config:
  timeout: 30
  variables:
    base_url: "https://httpbin.org"
    # 变量嵌套引用示例
    api_prefix: "/api"
    api_version: "v1"
    # ✅ 支持变量嵌套引用
    base_path: "${api_prefix}/${api_version}"
    # ✅ 支持多级嵌套
    full_url: "${base_url}${base_path}"

steps:
  # ==============================================================================
  # 1. JSONPath 过滤表达式演示
  # ==============================================================================

  - name: "创建测试数据（用户列表）"
    description: "准备用于演示过滤表达式的数据"
    type: request
    method: POST
    url: "${base_url}/anything"
    headers:
      Content-Type: "application/json"
    body:
      users:
        - {id: 1, name: "Alice", role: "admin", active: true}
        - {id: 2, name: "Bob", role: "user", active: true}
        - {id: 3, name: "Charlie", role: "admin", active: false}
        - {id: 4, name: "David", role: "user", active: true}
      products:
        - {id: 101, name: "Laptop", price: 999, category: "electronics", in_stock: true}
        - {id: 102, name: "Mouse", price: 29, category: "electronics", in_stock: true}
        - {id: 103, name: "Desk", price: 299, category: "furniture", in_stock: false}
        - {id: 104, name: "Chair", price: 149, category: "furniture", in_stock: true}
    extractors:
      # 保存创建的数据用于后续步骤
      - name: "test_users"
        path: "$.body.json.users"
      - name: "test_products"
        path: "$.body.json.products"
    validations:
      - type: status_code
        path: "$.status_code"
        expect: "200"

  # ==============================================================================
  # 2. 使用过滤表达式提取数据
  # ==============================================================================

  - name: "演示：提取所有管理员用户"
    description: "使用过滤表达式 [?(@.role == 'admin')]"
    type: script
    script: |
      # 模拟 JSONPath 过滤表达式
      # 实际使用中在 extractors 中使用：
      # path: "$.data.users[?(@.role == 'admin')].id"
      users = ${test_users}
      admin_ids = [u['id'] for u in users if u['role'] == 'admin']
      print(f"管理员 IDs: {admin_ids}")
      # 预期: [1, 3]
      return admin_ids
    validations:
      - type: exists
        path: "$.result"
        expect: true

  - name: "演示：提取活跃用户"
    description: "使用布尔值过滤 [?(@.active == true)]"
    type: script
    script: |
      # 注意：过滤表达式中布尔值使用小写 true/false
      users = ${test_users}
      active_users = [u['name'] for u in users if u['active']]
      print(f"活跃用户: {active_users}")
      return active_users
    validations:
      - type: exists
        path: "$.result"
        expect: true

  - name: "演示：提取库存商品（价格过滤）"
    description: "使用数值比较过滤 [?(@.price > 100)]"
    type: script
    script: |
      products = ${test_products}
      expensive = [p['name'] for p in products if p['price'] > 100]
      print(f"高价商品: {expensive}")
      return expensive
    validations:
      - type: exists
        path: "$.result"
        expect: true

  - name: "演示：组合条件过滤"
    description: "多个条件：电子类且库存充足"
    type: script
    script: |
      products = ${test_products}
      # 等价于: $.products[?(@.category == 'electronics' & @.in_stock == true)]
      result = [p['name'] for p in products
                if p['category'] == 'electronics' and p['in_stock']]
      print(f"符合条件的商品: {result}")
      return result
    validations:
      - type: exists
        path: "$.result"
        expect: true

  # ==============================================================================
  # 3. 数组索引和通配符演示
  # ==============================================================================

  - name: "演示：数组索引访问"
    description: "使用 $.array[index] 访问特定元素"
    type: script
    script: |
      users = ${test_users}
      # 等价于: $.data.users[0]
      first_user = users[0]
      # 等价于: $.data.users[1]
      second_user = users[1]
      # 等价于: $.data.users[-1]
      last_user = users[-1]
      return {
        'first': first_user['name'],
        'second': second_user['name'],
        'last': last_user['name']
      }
    validations:
      - type: eq
        path: "$.result.first"
        expect: "Alice"
      - type: eq
        path: "$.result.second"
        expect: "Bob"

  - name: "演示：通配符访问"
    description: "使用 [*] 获取所有元素的字段"
    type: script
    script: |
      users = ${test_users}
      # 等价于: $.data.users[*].name
      all_names = [u['name'] for u in users]
      # 等价于: $.data.users[*].id
      all_ids = [u['id'] for u in users]
      return {'names': all_names, 'ids': all_ids}
    validations:
      - type: length_eq
        path: "$.result.names"
        expect: 4
      - type: contains
        path: "$.result.names"
        expect: "Alice"

  # ==============================================================================
  # 4. 变量嵌套引用演示
  # ==============================================================================

  - name: "演示：多级变量嵌套"
    description: "验证嵌套变量引用的正确渲染"
    type: request
    method: POST
    url: "${base_url}/anything"
    headers:
      Content-Type: "application/json"
    # 使用嵌套变量构建请求体
    body:
      message: "API 路径: ${base_path}"
      full_path: "${full_url}"
      # 测试多级嵌套
      nested_test:
        level1: "${api_prefix}"
        level2: "${base_path}"
        level3: "${full_url}"
    validations:
      - type: status_code
        path: "$.status_code"
        expect: "200"
      # 验证嵌套变量正确渲染
      - type: eq
        path: "$.json.message"
        expect: "/api/v1"
      - type: eq
        path: "$.json.full_path"
        expect: "https://httpbin.org/api/v1"
      - type: eq
        path: "$.json.nested_test.level3"
        expect: "https://httpbin.org/api/v1"

  # ==============================================================================
  # 5. 微秒时间戳演示
  # ==============================================================================

  - name: "演示：微秒级时间戳生成"
    description: "使用 now_us() 和 timestamp_us() 生成唯一标识"
    type: request
    method: POST
    url: "${base_url}/anything"
    headers:
      Content-Type: "application/json"
    body:
      # 方式 1: 使用 now_us() 函数
      formatted_timestamp: "${now_us()}"
      # 方式 2: 使用 timestamp_us() 函数
      unix_timestamp_us: "${timestamp_us()}"
      # 方式 3: 使用 now().strftime('%f') 获取微秒部分
      microsecond_part: "${now().strftime('%Y%m%d%H%M%S%f')}"
      # 方式 4: 结合其他函数使用
      unique_id: "test_${now_us()}_${random_str(4)}"
    validations:
      - type: status_code
        path: "$.status_code"
        expect: "200"
      # 验证 now_us() 返回 20 位数字字符串
      - type: length_eq
        path: "$.json.formatted_timestamp"
        expect: 20
      - type: regex
        path: "$.json.formatted_timestamp"
        expect: "^\\d{20}$"
        description: "应为 20 位纯数字"
      # 验证 timestamp_us() 是一个大整数
      - type: gt
        path: "$.json.unix_timestamp_us"
        expect: 1000000000000000
        description: "微秒时间戳应大于此值"
      # 验证 unique_id 包含时间戳
      - type: regex
        path: "$.json.unique_id"
        expect: "^test_\\d{20}_"
        description: "应以 test_ 和时间戳开头"

  # ==============================================================================
  # 6. 实际应用场景演示
  # ==============================================================================

  - name: "实际场景：API 响应过滤和提取"
    description: "模拟真实 API 场景，使用过滤表达式提取特定数据"
    type: request
    method: POST
    url: "${base_url}/anything"
    headers:
      Content-Type: "application/json"
    body:
      # 模拟订单列表响应
      orders:
        - {id: "ORD001", customer: "Alice", amount: 150, status: "completed", paid: true}
        - {id: "ORD002", customer: "Bob", amount: 200, status: "pending", paid: false}
        - {id: "ORD003", customer: "Charlie", amount: 300, status: "completed", paid: true}
        - {id: "ORD004", customer: "David", amount: 250, status: "cancelled", paid: false}
        - {id: "ORD005", customer: "Alice", amount: 180, status: "completed", paid: true}
    extractors:
      # 提取所有已完成订单的 ID
      # JSONPath: $.data.orders[?(@.status == 'completed')].id
      - name: "completed_order_ids"
        path: "$.body.json.orders"
        # 注意：由于 jsonpath-ng 的限制，这里提取全部后在 script 中过滤
      # 提取已支付订单的总金额
      - name: "total_paid_amount"
        path: "$.body.json.orders"
    validations:
      - type: status_code
        path: "$.status_code"
        expect: "200"

  - name: "实际场景：数据分析"
    description: "对提取的数据进行过滤和分析"
    type: script
    script: |
      orders = ${completed_order_ids}

      # 模拟 JSONPath 过滤: [?(@.status == 'completed')]
      completed = [o for o in orders if o['status'] == 'completed']

      # 模拟 JSONPath 过滤: [?(@.paid == true)]
      paid = [o for o in orders if o['paid']]

      # 模拟 JSONPath 过滤: [?(@.amount > 200)]
      high_value = [o for o in orders if o['amount'] > 200]

      # 计算统计信息
      total_amount = sum(o['amount'] for o in completed)

      return {
        'completed_count': len(completed),
        'paid_count': len(paid),
        'high_value_count': len(high_value),
        'total_amount': total_amount
      }
    validations:
      - type: eq
        path: "$.result.completed_count"
        expect: 3
      - type: eq
        path: "$.result.paid_count"
        expect: 3
      - type: eq
        path: "$.result.total_amount"
        expect: 630

# ==============================================================================
# JSONPath 过滤表达式语法说明
# ==============================================================================
#
# 1. 基本过滤
#    $.array[?(@.field == 'value')]     # 等于
#    $.array[?(@.field != 'value')]     # 不等于
#    $.array[?(@.field > 10)]           # 大于
#    $.array[?(@.field < 10)]           # 小于
#
# 2. 布尔值过滤（注意使用小写 true/false）
#    $.array[?(@.active == true)]       # 等于 true
#    $.array[?(@.active == false)]      # 等于 false
#
# 3. 组合条件
#    $.array[?(@.field1 == 'value1' & @.field2 == 'value2')]  # AND
#    $.array[?(@.field1 == 'value1' | @.field2 == 'value2')]  # OR
#
# 4. 数组索引
#    $.array[0]                        # 第一个元素
#    $.array[-1]                       # 最后一个元素
#    $.array[*]                        # 所有元素（通配符）
#    $.array[0:3]                      # 切片（前 3 个元素）
#
# 5. 嵌套访问
#    $.data.users[?(@.role == 'admin')].name  # 提取管理员的 name 字段
#    $.data.items[*].price                       # 提取所有 items 的 price
#
# ==============================================================================

tags:
  - "JSONPath"
  - "过滤表达式"
  - "变量嵌套"
  - "微秒时间戳"
  - "高级功能"

enabled: true
